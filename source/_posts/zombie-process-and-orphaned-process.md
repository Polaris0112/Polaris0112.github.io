---
title: 浅析僵尸进程与孤儿进程
date: 2018-02-28
categories: 浅析僵尸进程与孤儿进程
tags: 
- Zombie Process
- Orphaned Process

---
本帖子记录的是理解僵尸进程和孤儿进程的产生原因

## 知识背景

在被誉为UNIX编程“圣经”的一书《unix环境高级编程》中有提到僵尸进程和孤儿进程。不少同学对这两个概念会混淆，这篇文章总结一下。

在unix/linux系统中，大多情况下，子进程是通过父进程fork创建的，注：系统调用fork，是一个比较有意思系统调用，它调用一次，返回两个值，失败返回-1,成功时在子进程返回0，父进程返回所创建子进程的pid。本文暂时只需了解这些就够了，有兴趣的同学可以查阅man文档，描述的非常清楚。

子进程创建后，子进程的结束和父进程的运行是一个异步过程,也就是说父进程没办法预测子进程什么时候结束。 当一个子进程完成它的工作终止之后，其父进程需要调用wait()或waitpid()去获取子进程的终止状态。



## 孤儿进程

首先来认识下什么叫孤儿进程，所谓孤儿进程，顾名思义，和现实生活中的孤儿有点类似，当一个进程的`父进程结束`时，但是它自己还没有结束，那么这个进程将会成为孤儿进程。最后孤儿进程将会被`init进程`（进程号为1）的进程收养，当然在子进程结束时也会由init进程完成对它的状态收集工作，因此一般来说，孤儿进程并不会有什么危害。

下面看一个关于**孤儿进程**的例子：在main函数中，创建子进程，然后让父进程睡眠1s，让子进程先运行打印出其进程id(pid)以及父进程id(ppid)；随后子进程睡眠3s（此时会调度到父进程运行直至结束），目的是`让父进程先于子进程结束`，让子进程有个孤儿的状态；最后子进程再打印出其进程id(pid)以及父进程id(ppid)；观察两次打印 其父进程id(ppid)的区别。


![orphaned-process-1](/images/orphaned-process-1.jpg)


![orphaned-process-2](/images/orphaned-process-2.jpg)


从运行结果来看：当其父进程结束后，子进程成为了孤儿进程，其父进程id(ppid)为1，也就是说，init进程成为该子进程的父进程了。



## 僵尸进程

好了，说完了孤儿进程，再来谈谈僵尸进程，其实对于这2两个概念（指孤儿进程与僵尸进程）不少人容易混淆，其实如果仔细理解的话，还是很容易区分的。

僵尸进程是指：一个进程使用fork创建子进程，如果**子进程退出**，而父进程并`没有调用`wait或waitpid获取子进程的状态信息，那么子进程的某些信息如进程描述符仍然保存在系统中。这种进程称之为僵死进程。

下面是1个关于**僵尸进程**的例子：在main函数中，创建子进程，然后让父进程睡眠10s，让子进程先终止（注意和孤儿进程例子的区别）；这里子进程结束后父进程没有调用wait/waitpid函数获取其状态，用ps查看进程状态可以看出子进程为僵尸状态。


![zombie-process-1](/images/zombie-process-1.jpg)

![zombie-process-2](/images/zombie-process-2.jpg)

![zombie-process-3](/images/zombie-process-3.jpg)

```bash
注：任何一个子进程(init除外)在exit()之后，并非马上就消失掉，而是留下一个称为僵尸进程(Zombie)的数据结构，等待父进程处理。这是每个子进程在结束时都要经过的阶段。如果子进程在exit()之后，父进程没有来得及处理，这时用ps命令就能看到子进程的状态是“Z”。如果父进程能及时 处理，可能用ps命令就来不及看到子进程的僵尸状态，但这并不等于子进程不经过僵尸状态。  如果父进程在子进程结束之前退出，则子进程将由init接管。init将会以父进程的身份对僵尸状态的子进程进行处理。
```


讲了僵尸进程产生的原因，再来讲讲僵尸进程的危害：僵尸进程会在系统中保留其某些信息如进程描述符、进程id等等。以进程id为例，系统中可用的进程id是有限的，如果由于系统中大量的僵尸进程占用进程id，就会导致因为没有可用的进程id系统不能产生新的进程，这种问题可就大了，这就是僵尸进程带来的危害。




## 如何杀死僵尸进程

如上可知，僵尸进程一旦出现之后，很难自己消亡，会一直存在下去，直至系统重启。虽然僵尸进程几乎不占系统资源，但是，这样下去，数量太多了之后，终究会给系统带来其他的影响。

请注意：defunct状态下的僵尸进程是不能直接使用kill -9命令杀掉的，否则就不叫僵尸进程了。

**解决方法**：

- 重启服务器，这个是最简单，最易用的方法，但是如果你服务器电脑上运行有其他的程序，那么这个方法，代价很大。所以，尽量使用下面一种方法。

- 找到该defunct僵尸进程的父进程，将该进程的父进程杀掉，则此defunct进程将自动消失。

参考命令：

```bash
$ ps -ef | grep defunct_process_pid
```



## 如何预防僵尸进程

以上介绍的只是在发现了僵尸进程之后，如何去杀死它。那么，有同学可能会说了，这个是治标不治本的。真正的办法是，不让它产生，问题才能彻底解决。

- 在父进程创建子进程之前，就向系统申明自己并不会对这个子进程的exit动作进行任何关注行为，这样的话，子进程一旦退出后，系统就不会去等待父进程的操作，而是直接将该子进程的资源回收掉，也就不会出现僵尸进程了。具体的办法就是，在父进程的初始化函数中，调用这个函数：signal(SIGCHLD,SIG_IGN)；

- 如果上述语句没来得及调用，也有另外一个办法。那就是在创建完子进程后，用waitpid等待子进程返回，也能达到上述效果；

- 如果上述两个办法都不愿意采用，那还有一招：在父进程创建子进程的时候，连续调用两次fork()，而且使紧跟的子进程直接退出，使其孙子进程成为孤儿进程，从而init进程将代替父进程来接手，负责清除这个孤儿进程。于是，父进程就无需进行任何的清理行为，系统会自动处理；





